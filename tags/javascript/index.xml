<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on 小明plus</title>
    <link>http://xiaomingplus.com/tags/javascript/</link>
    <description>Recent content in Javascript on 小明plus</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 24 Sep 2016 02:52:18 +0800</lastBuildDate>
    <atom:link href="http://xiaomingplus.com/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>学会fetch的用法</title>
      <link>http://xiaomingplus.com/front-end/understand-fetch/</link>
      <pubDate>Sat, 24 Sep 2016 02:52:18 +0800</pubDate>
      
      <guid>http://xiaomingplus.com/front-end/understand-fetch/</guid>
      <description>&lt;p&gt;fetch是web提供的一个可以获取异步资源的api，目前还没有被所有浏览器支持，它提供的api返回的是Promise对象，所以你在了解这个api前首先得了解Promise的用法。参考&lt;a href=&#34;http://javascript.ruanyifeng.com/advanced/promise.html&#34;&gt;阮老师的文章&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;那我们首先讲讲在没有fetch的时候，我们是如何获取异步资源的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//发送一个get请求是这样的:

//首先实例化一个XMLHttpRequest对象
var httpRequest = new XMLHttpRequest();

//注册httpRequest.readyState改变时会回调的函数,httpRequest.
//readyState共有5个可能的值,
//0	UNSENT (未打开)	open()方法还未被调用;
//1	OPENED  (未发送)	send()方法还未被调用;
//2	HEADERS_RECEIVED (已获取响应头)	send()方法已经被调用, 响应头和响应状态已经返回;
//3	LOADING (正在下载响应体)	响应体下载中; responseText中已经获取了部分数据;
//4	DONE (请求完成)	整个请求过程已经完毕.
httpRequest.onreadystatechange = function(){
 //该回调函数会被依次调用4次
 console.log(httpRequest.readyState);

 if(httpRequest.readyState===4){
   //请求已完成
   if(httpRequest.status===200){
     //http状态为200
     console.log(httpRequest.response);

     var data = JSON.parse(httpRequest.response);
     console.log(data);
   }
 }

}

//请求的网址
var url = &amp;quot;http://127.0.0.1:7777/list&amp;quot;;
//该方法为初始化请求,第一个参数是请求的方法,比如GET,POST,PUT,第二个参数是请求的url
httpRequest.open(&#39;GET&#39;,url,true);

//设置http请求头
httpRequest.setRequestHeader(&amp;quot;Content-Type&amp;quot;,&amp;quot;application/json&amp;quot;);

//发出请求,参数为要发送的body体,如果是GET方法的话，一般无需发送body,设为空就可以
httpRequest.send(null);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于XMLHttpRequest的更多用法请参照:&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#open(&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#open()&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;如果用了fetch之后，发送一个get请求是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//请求的网址
var url = &amp;quot;http://127.0.0.1:7777/list&amp;quot;;
//发起get请求
var promise = fetch(url).then(function(response) {

   //response.status表示响应的http状态码
   if(response.status === 200){
     //json是返回的response提供的一个方法,会把返回的json字符串反序列化成对象,也被包装成一个Promise了
     return response.json();
   }else{
     return {}
   }

});
    
promise = promise.then(function(data){
  //响应的内容
	console.log(data);
}).catch(function(err){
	console.log(err);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来介绍下fetch的语法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
参数:
input:定义要获取的资源。可能的值是：一个URL或者一个Request对象。
init:可选,是一个对象，参数有：
	method: 请求使用的方法，如 GET、POST。
	headers: 请求的头信息，形式为 Headers 对象或 ByteString。
	body: 请求的 body 信息：可能是一个 Blob、BufferSource、FormData、URLSearchParams 或者 USVString 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。
	mode: 请求的模式，如 cors、 no-cors 或者 same-origin,默认为no-cors,该模式允许来自 CDN 的脚本、其他域的图片和其他一些跨域资源，但是首先有个前提条件，就是请求的 method 只能是HEAD、GET 或 POST。此外，如果 ServiceWorkers 拦截了这些请求，它不能随意添加或者修改除这些之外 Header 属性。第三，JS 不能访问 Response 对象中的任何属性，这确保了跨域时 ServiceWorkers 的安全和隐私信息泄漏问题。cors模式允许跨域请求,same-origin模式对于跨域的请求，将返回一个 error，这样确保所有的请求遵守同源策略。
	credentials: 请求的 credentials，如 omit、same-origin 或者 include。
	cache:  请求的 cache 模式: default, no-store, reload, no-cache, force-cache, or only-if-cached.
返回值：一个 Promise，resolve 时回传 Response 对象。
*/
fetch(input, init).then(function(response) {  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个发送post请求的示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fetch(&amp;quot;http://127.0.0.1:7777/postContent&amp;quot;, {
  method: &amp;quot;POST&amp;quot;,
  headers: {
      &amp;quot;Content-Type&amp;quot;: &amp;quot;application/json&amp;quot;,
  },
  mode: &amp;quot;cors&amp;quot;,
  body: JSON.stringify({
      content: &amp;quot;留言内容&amp;quot;
  })
}).then(function(res) {
  if (res.status === 200) {
      return res.json()
  } else {
      return Promise.reject(res.json())
  }
}).then(function(data) {
  console.log(data);
}).catch(function(err) {
  console.log(err);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果考虑低版本浏览器的问题的话，引入&lt;a href=&#34;https://github.com/github/fetch/blob/master/fetch.js&#34;&gt;https://github.com/github/fetch/blob/master/fetch.js&lt;/a&gt; 即可兼容。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;http://bubkoo.com/2015/05/08/introduction-to-fetch/&#34;&gt;http://bubkoo.com/2015/05/08/introduction-to-fetch/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>理解javascript中的原型</title>
      <link>http://xiaomingplus.com/front-end/understand-javascript-prototype/</link>
      <pubDate>Sun, 24 Jul 2016 18:50:34 +0800</pubDate>
      
      <guid>http://xiaomingplus.com/front-end/understand-javascript-prototype/</guid>
      <description>

&lt;h2 id=&#34;概述:459a545d6f3664b564482601d4d2ffee&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;javascript的灵魂应该就是原型了吧，可以说在js里一切皆有原型的影子，js中用原型实现继承，使得我们在实例对象中除了可以访问实例对象自己的属性外，还可以访问到它的原型的属性，以及它的原型的原型的属性，只要在它的原型链里面我们就都能访问到。不过如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。JavaScript的每个对象都继承自另一个对象，后者称为“原型”（prototype）对象。只有null除外，它没有自己的原型对象。比如说我们定义一个简单的对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var o = {
  a:1,
  b:2
}
// 这里，我们不仅可以访问o自己的属性o.a，我们还可以访问的o的原型Object.prototype的所有属性，比如o.toString(),toString就是Object.prototype里的属性，Object.prototype也有自己的原型:null，null没有原型。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js提供了一个获取某个对象原型的方法&lt;code&gt;Object.getPrototypeOf()&lt;/code&gt;，我们可以用这个方法来查看&lt;code&gt;o&lt;/code&gt;的原型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var oPrototype = Object.getPrototypeOf(o);
//我们会发现o的原型就等于下面的这个东西：
oPrototype === Object.prototype;

//而Object.prototype的原型等于null这个鬼东西
Object.getPrototypeOf(Object.prototype) === null;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;js中创建对象的方法:459a545d6f3664b564482601d4d2ffee&#34;&gt;js中创建对象的方法&lt;/h2&gt;

&lt;p&gt;js中有至少3种方法来创建对象（同时会生成所创建对象的原型链）：&lt;/p&gt;

&lt;h3 id=&#34;使用普通语法创建对象:459a545d6f3664b564482601d4d2ffee&#34;&gt;使用普通语法创建对象&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var obj1 = {};

//这个时候obj1的原型链:
Object.getPrototypeOf(obj1) === Object.prototype;
Object.getPrototypeOf(Object.prototype) === null;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-object-create-创建对象:459a545d6f3664b564482601d4d2ffee&#34;&gt;使用&lt;code&gt;Object.create&lt;/code&gt;创建对象&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var obj2 = Object.create(Object.prototype);

//这里的obj2其实和obj1是一毛一样的，{}其实相当于Object.create的语法糖，obj2的原型链也和obj1的一样，Object.create方法的第一个参数就是显式的指定要创建的对象的原型。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用函数创建对象:459a545d6f3664b564482601d4d2ffee&#34;&gt;使用函数创建对象&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//Object其实是一个函数

var obj3 = new Object();

//这里的obj3其实和obj1和2是一样的，用new来创建对象时，会把函数的prototype属性（这个示例中就是Object.prototype）作为创建对象的原型，也就是
Object.getPrototypeOf(obj3) === Object.prototype;

//事实上所有的函数都拥有一个prototype属性(事实上也只有函数才拥有这个属性)，所有使用new来创建的对象，他们的原型均是该函数的prototype,比如：

var F = function(){

};
var a = new F();

//这是a的原型
Object.getPrototypeOf(a) === F.prototype;

//我们可以a被创建后或创建之前给F.prototype增加一些属性，由于a的原型是F.prototype，所以在a上就能访问到F.prototype的所有属性

F.prototype.test = function(){
  return 1;
}
F.prototype.value = 2;

console.log(a.test()); // 1
console.log(a.value); //2


//所有继承F的对象，都拥有F.prototype的所有属性
var b = new F();

b.test();// 1  
b.value; //2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;理解js中常见类型的原型链:459a545d6f3664b564482601d4d2ffee&#34;&gt;理解js中常见类型的原型链&lt;/h2&gt;

&lt;p&gt;这个时候，我们可以看看js中常见的一些类型比如数组、函数的原型链。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr1 = [];
//上面这个定义与下面的这个等价：
var arr2 = new Array(); //Array其实就是个函数，js环境默认给Array函数的prototype添加了一些属性，比如join,push等，所以数组其实就是Array函数的一个实例化对象，所以我们可以在数组中使用Array.prototype中所有的属性

//arr1和arr2的原型链均如下：
Object.getPrototypeOf(arr1) === Array.prototype;
Object.getPrototypeOf(Array.prototype) === Object.prototype;
Object.getPrototypeOf(Object.prototype) === null;
//null其实是所有对象原型的老祖宗
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再来看看函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fun1 = function(arg){return 1;}
var fun2 = new Function(&amp;quot;arg&amp;quot;,&amp;quot;return 1;&amp;quot;);
//fun1和fun2是全等的（但对于js引擎来讲fun1的效率更高，所以不推荐用fun2这种来定义函数
// fun1和fun2的原型链均如下：
Object.getPrototypeOf(fun1) === Function.prototype;
Object.getPrototypeOf(Function.prototype) === Object.prototype;
Object.getPrototypeOf(Object.prototype) === null;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，我们不能用&lt;code&gt;Object.create()&lt;/code&gt;来创建函数对象和数组,为什么呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Object.create这个方法的定义其实就是下面这个：
Object.create = function (o) {
    function F() {}
    F.prototype = o;
    return new F();
  };

//所以我们只能说只要能用create来创建的对象就一定能用new来创建，反之则不然。因为使用new的话F这个函数里面可能要做一些处理，但是Object.create就无法做任何处理。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>如何使用webpack开始一个react项目?</title>
      <link>http://xiaomingplus.com/front-end/how-to-start-react-redux-react-router-webpack-project/</link>
      <pubDate>Sat, 16 Apr 2016 02:52:18 +0800</pubDate>
      
      <guid>http://xiaomingplus.com/front-end/how-to-start-react-redux-react-router-webpack-project/</guid>
      <description>&lt;p&gt;本文是讲实战操作的，会使用到react,react-router,webpack,babel,react热启动,webpack热启动等，而且本文不准备对原理等进行说明，只想让新手能迅速自己动手生成自己的第一个demo，想了解原理的朋友推荐以下两个教程，讲的非常好。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://survivejs.com/webpack/advanced-techniques/configuring-react/&#34;&gt;http://survivejs.com/webpack/advanced-techniques/configuring-react/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cn.redux.js.org/index.html&#34;&gt;http://cn.redux.js.org/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个是一个讲webpack的配置的教程，是英文版的，有国内的翻译，但是太旧了，所以推荐看英文版本的，第二个是国内翻译的redux教程文档，讲的非常好，暂时还挺新的，如果想看英文版，里面也有对应的链接。&lt;/p&gt;

&lt;p&gt;直接开始吧，本文只讲如何配置，以及如何写一个简单的示例。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意！！！本文在os操作系统下保证可以运行，其他操作系统请勿跟随该示例。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;第一步：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir react-demo
cd react-demo
npm init -y
npm i webpack webpack-dev-server html-webpack-plugin webpack-merge babel-loader babel-core css-loader style-loader babel-preset-react-hmre babel-preset-es2015 babel-preset-react -D
mkdir app
mkdir dist
mkdir assets
touch assets/index.tmpl.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二步，编辑index.tmpl.html为如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;Content-type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;/&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;%= htmlWebpackPlugin.options.title %&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&amp;quot;root&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二步，打开你的&lt;code&gt;package.json&lt;/code&gt;文件,添加如下字符串:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
&amp;quot;scripts&amp;quot;: {    
  &amp;quot;build&amp;quot;: &amp;quot;webpack&amp;quot;,
  &amp;quot;start&amp;quot;: &amp;quot;webpack-dev-server&amp;quot;
},
&amp;quot;babel&amp;quot;:{
  &amp;quot;presets&amp;quot;: [
    &amp;quot;es2015&amp;quot;,
    &amp;quot;react&amp;quot;
  ],
  &amp;quot;env&amp;quot;: {
      &amp;quot;start&amp;quot;: {
        &amp;quot;presets&amp;quot;: [
          &amp;quot;react-hmre&amp;quot;
        ]
      }
    }
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三步：在根目录新建一个&lt;code&gt;webpack.config.js&lt;/code&gt;的文件,写入如下配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const webpack = require(&#39;webpack&#39;);
const merge = require(&#39;webpack-merge&#39;);
const TARGET = process.env.npm_lifecycle_event;
process.env.BABEL_ENV = TARGET;
const PATHS = {
  app: path.join(__dirname, &#39;app&#39;),
  build: path.join(__dirname, &#39;dist&#39;),
  template: path.resolve(__dirname, &#39;assets&#39;, &#39;index.tmpl.html&#39;),
};
const common = {
  entry: {
    app: PATHS.app,
  },
  output: {
    path: PATHS.build,
    filename: &#39;bundle.js&#39;,
  },
  plugins: [
    new HtmlWebpackPlugin({
      title: &#39;react demo&#39;,
      template: PATHS.template,
      inject: &#39;body&#39;,
    }),
  ],
  module: {
    loaders: [{
      test: /\.jsx?$/,
      loaders: [&#39;babel?cacheDirectory&#39;],
      include: PATHS.app,
    }, {
      test: /\.css$/,
      loaders: [&#39;style&#39;, &#39;css&#39;],
      include: PATHS.app,
    }],
  },
  resolve: {
    extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.jsx&#39;],
  },
};
if (TARGET === &#39;start&#39; || !TARGET) {
  module.exports = merge(common, {
    devtool: &#39;eval-source-map&#39;,
    devServer: {
      contentBase: &#39;/dist&#39;,
      historyApiFallback: true,
      hot: true,
      inline: true,
      progress: true,
      stats: &#39;errors-only&#39;,
    },
    plugins: [
      new webpack.HotModuleReplacementPlugin(),
    ],

  });
}
if (TARGET === &#39;build&#39;) {
  module.exports = merge(common, {});
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第四步：到这里，关于react的需要的webpack方面的配置就结束了，接下来我们来写一个很小的示例来生成一个真正的react文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm i react react-dom react-router -S
touch app/App.jsx
touch app/index.jsx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑&lt;code&gt;App.jsx&lt;/code&gt;文件如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import React, { Component } from &#39;react&#39;;
import {
    Router,
    Route,
    Link,
    IndexLink,
    IndexRoute,
    hashHistory,
} from &#39;react-router&#39;;

const activeStyle = {
  color: &#39;#53acff&#39;,
};
const Nav = () =&amp;gt; (
    &amp;lt;div&amp;gt;
        &amp;lt;IndexLink onlyActiveOnIndex activeStyle={activeStyle} to=&amp;quot;/&amp;quot;&amp;gt;主页&amp;lt;/IndexLink&amp;gt;
        &amp;amp;nbsp;
        &amp;lt;IndexLink onlyActiveOnIndex activeStyle={activeStyle} to=&amp;quot;/address&amp;quot;&amp;gt;地址&amp;lt;/IndexLink&amp;gt;
        &amp;amp;nbsp;
    &amp;lt;/div&amp;gt;
);

const Container = (props) =&amp;gt; &amp;lt;div&amp;gt;
    &amp;lt;Nav /&amp;gt; { props.children }
&amp;lt;/div&amp;gt;;

const Twitter = () =&amp;gt; &amp;lt;div&amp;gt;@xiaomingplus twitter&amp;lt;/div&amp;gt;;
const Instagram = () =&amp;gt; &amp;lt;div&amp;gt;@xiaomingplus instagram&amp;lt;/div&amp;gt;;

const NotFound = () =&amp;gt; (
    &amp;lt;h1&amp;gt;404.. 找不到该页面!&amp;lt;/h1&amp;gt;
);
const Home = () =&amp;gt; &amp;lt;h1&amp;gt;你好，这是主页。&amp;lt;/h1&amp;gt;;
const Address = (props) =&amp;gt; &amp;lt;div&amp;gt;
    &amp;lt;br /&amp;gt;
    &amp;lt;Link activeStyle={{ color: &#39;#53acff&#39; }} to=&amp;quot;/address&amp;quot;&amp;gt;这是Twitter&amp;lt;/Link&amp;gt; &amp;amp;nbsp;
    &amp;lt;Link to=&amp;quot;/address/instagram&amp;quot;&amp;gt;这是Instagram&amp;lt;/Link&amp;gt;
    &amp;lt;h1&amp;gt;欢迎互关！&amp;lt;/h1&amp;gt;
    { props.children }
&amp;lt;/div&amp;gt;;


class App extends Component {
  construct() {
  }
  render() {
    return (
        &amp;lt;Router history={hashHistory}&amp;gt;
            &amp;lt;Route path=&amp;quot;/&amp;quot; component={Container}&amp;gt;
                &amp;lt;IndexRoute component={Home} /&amp;gt;
                &amp;lt;Route path=&amp;quot;/address&amp;quot; component={Address}&amp;gt;
                    &amp;lt;IndexRoute component={Twitter} /&amp;gt;
                    &amp;lt;Route path=&amp;quot;instagram&amp;quot; component={Instagram} /&amp;gt;
                &amp;lt;/Route&amp;gt;
                &amp;lt;Route path=&amp;quot;*&amp;quot; component={NotFound} /&amp;gt;
            &amp;lt;/Route&amp;gt;
        &amp;lt;/Router&amp;gt;
    );
  }
}

export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑&lt;code&gt;index.jsx&lt;/code&gt;文件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import App from &#39;./App.jsx&#39;;

ReactDOM.render(
    &amp;lt;App /&amp;gt;, document.getElementById(&#39;root&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ok,到这里你已经实用react-router构建了一个有路由的应用，接下来启动这个应用吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用浏览器访问:&lt;code&gt;http://localhost:8080&lt;/code&gt;,你将看到如下界面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/d9f8fd81gw1f32ivzlj5yj20wi0j240c.jpg&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;http://ww2.sinaimg.cn/large/d9f8fd81gw1f32iyh9nw4j20w60iuwgv.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>几句话理解javascript中的执行上下文、this、作用域、闭包</title>
      <link>http://xiaomingplus.com/front-end/understand-javascript-execution-context-and-this-and-scope-closure/</link>
      <pubDate>Wed, 06 Jan 2016 02:52:18 +0800</pubDate>
      
      <guid>http://xiaomingplus.com/front-end/understand-javascript-execution-context-and-this-and-scope-closure/</guid>
      <description>

&lt;p&gt;这几个问题是javascript问题中的老大难的几个问题，很多文章都有讲过这几个问题，但总也讲不清楚，希望可以尝试用最简单明了的语言把这几个事儿给说清楚了，部分内容并不是官方的定义，而是用简单易懂的语言表达出我所理解的概念。&lt;/p&gt;

&lt;h3 id=&#34;概念:aaa6854c088f9b36a66d3f82ec1dff83&#34;&gt;概念&lt;/h3&gt;

&lt;h4 id=&#34;执行上下文:aaa6854c088f9b36a66d3f82ec1dff83&#34;&gt;执行上下文&lt;/h4&gt;

&lt;p&gt;首先明确一点，所有的js代码都是在某个执行上下文中运行的。&lt;/p&gt;

&lt;p&gt;执行上下文可以看成以下对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;executionContextObj = {
    scopeChain: { /* 作用域链：变量对象+ 所有父执行上下文的变量对象*/ },
    variableObject: { /*变量对象：函数 arguments/参数，内部变量和函数声明 */ },
    this: { /*运行这个函数的对象(动态的) */ }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js解释器实现了一个执行上下文堆栈，并且总是在栈顶的执行上下文中执行代码。&lt;/p&gt;

&lt;p&gt;当js解释器初始化执行代码时，它首先默认压入一个全局执行上下文到栈中，在此基础上任何一次函数的调用都将压入一个新的执行上下文到栈中，函数执行结束后该执行上下文被弹出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/large/d9f8fd81gw1exnvbj1v68j20ff080my4.jpg&#34; alt=&#34;test&#34; /&gt;&lt;/p&gt;

&lt;p&gt;创建执行上下文是根据按照以下步骤创建的（有先后顺序）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建当前执行上下文的变量对象（在函数中称为活跃对象）：

&lt;ol&gt;
&lt;li&gt;创建arguments对象（如果是函数调用的话），初始化参数名称和值并创建引用的复制。其属性名就是形参的名字，其值就是实参的值；对于没有传递的参数，其值为undefined&lt;/li&gt;
&lt;li&gt;扫描当前执行上下文内的所有函数声明：为发现的每一个函数，在变量对象上创建一个属性，属性名是函数的名字，并且指向函数在内存中的引用，如果变量对象已经包含了相同名字的属性，则替换他的值为当前函数在内存中的引用。（这里的函数扫描只扫描用函数声明定义的函数，不包括函数表达式定义的函数）&lt;/li&gt;
&lt;li&gt;扫描当前执行上下文内的所有变量声明：为发现的每个变量声明，在变量对象上创建一个属性，属性名就是变量的名字，并且将变量的值初始化为undefined，如果变量的名字已经在变量对象里存在，则不会进行任何操作并继续扫描，&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;求出执行上下文内部“this”的值：在全局运行上下文中（在任何函数体外部），this 指代全局对象，无论是否在严格模式下；在函数内部，this的值取决于函数是如何调用的。（关于求this的值，本文后面再讲）&lt;/li&gt;
&lt;li&gt;初始化作用域链：作用域链对执行上下文中的变量对象的有序访问的链表，包括当前执行上下文的变量对象，以及包含了所有上层变量对象的分层链（在函数创建时静态保存在函数中的）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;整个js代码的执行机制就是上面所说的，上面的内容其实包括了执行上下文、作用域链、提升机制，有了以上知识储备，我们再来理解这些难懂的概念就比较容易了：&lt;/p&gt;

&lt;h4 id=&#34;作用域:aaa6854c088f9b36a66d3f82ec1dff83&#34;&gt;作用域&lt;/h4&gt;

&lt;p&gt;作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在js中，变量的作用域有全局作用域和局部作用域两种。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全局作用域：在代码中任何地方都能访问到的对象拥有全局作用域，有以下几种：

&lt;ul&gt;
&lt;li&gt;在最外层定义的变量；&lt;/li&gt;
&lt;li&gt;全局对象的属性；&lt;/li&gt;
&lt;li&gt;任何地方隐式定义的变量（未定义直接赋值的变量），在任何地方隐式定义的变量都会定义在全局作用域中，即不通过 var 声明直接赋值的变量。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;局部作用域：JavaScript的作用域是通过函数来定义的，在一个函数中定义的变量只对这个函数内部可见，称为函数（局部）作用域&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;this:aaa6854c088f9b36a66d3f82ec1dff83&#34;&gt;this&lt;/h4&gt;

&lt;p&gt;在函数执行时，this 总是指向调用该函数的对象。要判断 this 的指向，其实就是判断 this 所在的函数属于谁。
this 出现的场景分为四类，简单的说就是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有对象就指向调用对象&lt;/li&gt;
&lt;li&gt;没调用对象就指向全局对象&lt;/li&gt;
&lt;li&gt;用new构造就指向新对象&lt;/li&gt;
&lt;li&gt;通过 apply 或 call 或 bind 来改变 this 的所指。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;闭包:aaa6854c088f9b36a66d3f82ec1dff83&#34;&gt;闭包&lt;/h4&gt;

&lt;p&gt;闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。闭包是指函数有自由独立的变量。换句话说，定义在闭包中的函数可以“记忆”它创建时候的环境。定义在闭包中的函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。&lt;/p&gt;

&lt;h3 id=&#34;例子:aaa6854c088f9b36a66d3f82ec1dff83&#34;&gt;例子&lt;/h3&gt;

&lt;p&gt;//todo&lt;/p&gt;

&lt;h3 id=&#34;总结:aaa6854c088f9b36a66d3f82ec1dff83&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;//todo&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/&#34;&gt;http://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://segmentfault.com/a/1190000002692982&#34;&gt;http://segmentfault.com/a/1190000002692982&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.5ibc.net/p/17359.html&#34;&gt;http://blog.5ibc.net/p/17359.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yanhaijing.com/javascript/2014/04/30/JavaScript-Scoping-and-Hoisting/&#34;&gt;http://yanhaijing.com/javascript/2014/04/30/JavaScript-Scoping-and-Hoisting/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/alsotang/node-lessons/tree/master/lesson11&#34;&gt;https://github.com/alsotang/node-lessons/tree/master/lesson11&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://segmentfault.com/a/1190000000533094&#34;&gt;http://segmentfault.com/a/1190000000533094&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.k68.org/?p=1831&#34;&gt;http://www.k68.org/?p=1831&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>