<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Full-stacks on 小明plus</title>
    <link>http://xiaomingplus.com/full-stack/</link>
    <description>Recent content in Full-stacks on 小明plus</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 08 Oct 2016 22:56:36 +0800</lastBuildDate>
    <atom:link href="http://xiaomingplus.com/full-stack/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>javascript到底是如何运行的?</title>
      <link>http://xiaomingplus.com/full-stack/how-javascript-runing/</link>
      <pubDate>Sat, 08 Oct 2016 22:56:36 +0800</pubDate>
      
      <guid>http://xiaomingplus.com/full-stack/how-javascript-runing/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;本文在发出后收到了@开发者小蓝,@小水的诸多斧正，我修改了文中不严谨的地方，顺便把他们的原文贴出来供大家参考。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;开发者小蓝：&lt;a href=&#34;http://lanhao.name/article/302v&#34;&gt;致杨先生,关于《javascript到底是如何运行的》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;小水的QQ群回复：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;JS 引擎不需要区分什么“自己能执行什么”，它只是按各种名字（引用）在运行时作用域中找函数（方法）并调用它&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;至于被调用的函数 多久执行完，取决于其内部实现（JS 引擎、宿主环境 或 JS 程序员写的代码）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;只要不断调用的函数 是 JS 同步程序，JS 引擎 函数调用栈 就越来越深，直到内层函数不断返回，调用栈才会最终销毁&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若被调用的函数不是 JS 代码，那调用栈就此封顶，因为接下来执行的是引擎/宿主的代码（C、C++、Java 等），调用栈在其内部继续展开&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;JS 代码本身都是“同步/顺序执行”，JS 异步能力是由引擎、宿主提供的，所有异步 API 都是内部引用传入的回调函数后直接返回，再在特定条件下，把回调压入异步队列，再由 JS 引擎在空闲时一一取出来同步执行&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下是我的文章：&lt;/p&gt;

&lt;p&gt;每次看到别人在讲javascript单线程、事件循环、运行时、执行栈都似懂非懂，今天看了很多相关资料说一说我的理解吧。&lt;/p&gt;

&lt;p&gt;javascript的运行机制可抽象为3部分，一部分是[执行栈]，一部分为[任务队列]，另外一部分为[观察者]。&lt;/p&gt;

&lt;h3 id=&#34;执行栈:55bab40903563f7c350f32cba87d2249&#34;&gt;执行栈&lt;/h3&gt;

&lt;p&gt;[执行栈]就是我们常说的js的单线程，也叫主线程，js代码在这里被一行一行的执行，[执行栈]遇到它能搞定的语句，包括所有的计算型的语句，以及普通的函数回调，都能在这里直接执行。当[执行栈]遇到自己处理不了的语句(比如setTimeout，ajax，文件读取等)，那么它会把这个语句交给[观察者].然后继续执行[执行栈]剩下的语句,直到执行栈为空后，它会轮询[任务队列]里的任务。&lt;/p&gt;

&lt;h3 id=&#34;观察者:55bab40903563f7c350f32cba87d2249&#34;&gt;观察者&lt;/h3&gt;

&lt;p&gt;在js中，有多种类型的观察者，包括文件I/O观察者,网络请求观察者等（其实这里的观察者一般来讲就是宿主环境提供的API），[执行栈]会把自己搞不定的事情丢给相应类型的[观察者],[观察者]负责在该事情处理之后会把带着处理结果的回调函数加入[任务队列]。&lt;/p&gt;

&lt;h3 id=&#34;任务队列:55bab40903563f7c350f32cba87d2249&#34;&gt;任务队列&lt;/h3&gt;

&lt;p&gt;一个JavaScript运行时包含一个待处理的任务队列，该队列是先进先出的，队列里的每一个任务都与一个函数相关联（一般是调用API时指定的回调函数）。当[执行栈]为空时，[执行栈]会从[任务队列]中取出队列里最前面的一个任务进行处理。处理过程包含了调用与这个任务相关联的函数（以及因此而创建的一个初始栈结构）。当[执行栈]再次为空的时候，意味着该任务处理结束， [执行栈]会循环去[任务队列]取出排在最前面的任务，然后执行之，也就是说每一个任务在执行完成后（执行当前任务的执行栈为空的时候），其它任务才会被执行。如果任务队列里没有任务了，那执行栈会同步的等待任务队列的任务到来。&lt;/p&gt;

&lt;p&gt;用一张图来表示的话，如下图所示:
&lt;img src=&#34;http://ww4.sinaimg.cn/large/006bEpFbgw1f8jw4zax6dj30so0l2wfo.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;举例来讲:55bab40903563f7c350f32cba87d2249&#34;&gt;举例来讲：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
//0. 首先初始化本次执行栈,压入一个初始化的东西
console.log(&#39;a1&#39;);//1. 把console.log和压入执行栈,执行后就弹出（console.log这种事情执行栈完全可以处理）

var average = function(x,y,callback){
    callback((x+y)/2);
}

var start = function(){

    setTimeout(function(){

        console.log(&#39;time!&#39;);//13. 把console.log压入执行栈，执行后弹出
        //14. 到这里后，setTimeout的回调函数已执行完毕，弹出该函数

    },1000);//3. 把setTimeout压入执行栈,发现执行栈无法处理setTimeout函数，于是把setTimeout交给时间观察者，执行栈弹出setTimeout,时间观察者会在时间到了之后把回调函数加入任务队列。

    average(3,5,function(result){

        console.log(result);//4.1 这里的回调函数不会加入任务队列，因为这种普通的回调执行栈自己完全可以处理，不需要观察者帮忙。这里会打印出4

    })//4. 把average压入执行栈，执行完average函数后弹出average函数

    //5. 到这里后，start函数已执行完毕，弹出start函数
}

var end = function(){

    console.log(&#39;end!&#39;);//7. 把console.log压入执行栈，执行后弹出

    //8. 到这里后，end函数已执行完毕，弹出end函数
}

start();//2. 把start压入执行栈

end();//6. 到这里后,执行栈只剩下初始化的那个东西，把end压入执行栈

//9. 到这里后已经没有代码可执行，弹出初始化的那个东西，执行栈为空了
//10. 执行栈为空之后，它便去任务队列读取排在最前面的那个任务，发现任务队列里没有任务，于是同步的等待任务队列，1s过后，任务队列里会出现刚刚setTimeout时指定的回调函数。
//11. 初始化本次执行栈，压入一个初始化的东西
//12. 把setTimeout的回调函数压入执行栈
//15. 到这里后已经没有代码可执行，弹出第二次初始化的那个东西，执行栈为空了
//16. 执行栈为空之后，它便去任务队列读取排在最前面的那个任务，发现任务队列里没有任务，于是同步的等待任务队列。（看这情况，也不会出现别的任务了。。。）

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>nodejs中exports和module.exports的区别</title>
      <link>http://xiaomingplus.com/full-stack/understand-nodejs-export-and-module-export/</link>
      <pubDate>Sat, 16 Jan 2016 18:21:09 +0800</pubDate>
      
      <guid>http://xiaomingplus.com/full-stack/understand-nodejs-export-and-module-export/</guid>
      <description>&lt;p&gt;&lt;strong&gt;用一句话来说明就是，require方能看到的只有module.exports这个对象，它是看不到exports对象的，而我们在编写模块时用到的exports对象实际上只是对module.exports的引用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果你能理解上面这句话，那么下面的都是废话，可以不用看了，因为是用来解释上面这句话的。&lt;/p&gt;

&lt;p&gt;关于引用，可以用下面的例子来让你搞得请清楚楚的：&lt;/p&gt;

&lt;p&gt;首先说一个概念：&lt;/p&gt;

&lt;p&gt;ECMAScript的变量值类型共有两种：&lt;/p&gt;

&lt;p&gt;基本类型 (primitive values) ： 包括Undefined, Null, Boolean, Number和String五种基本数据类型；&lt;/p&gt;

&lt;p&gt;引用类型 (reference values) ： 保存在内存中的对象们，不能直接操作，只能通过保存在变量中的地址引用对其进行操作。&lt;/p&gt;

&lt;p&gt;我们今天要讨论的exports和module.exports属于Object类型，属于引用类型。&lt;/p&gt;

&lt;p&gt;看下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var module = {
    exports:{
        name:&amp;quot;我是module的exports属性&amp;quot;
    }
};
var exports = module.exports;  //exports是对module.exports的引用，也就是exports现在指向的内存地址和module.exports指向的内存地址是一样的

console.log(module.exports);    //  { name: &#39;我是module的exports属性&#39; }
console.log(exports);   //  { name: &#39;我是module的exports属性&#39; }


exports.name = &amp;quot;我想改一下名字&amp;quot;;


console.log(module.exports);    //  { name: &#39;我想改一下名字&#39; }
console.log(exports);   //  { name: &#39;我想改一下名字&#39; }
//看到没，引用就是a和b都操作同一内存地址下的数据


//这个时候我在某个文件定义了一个想导出的模块
var Circle = {
    name:&amp;quot;我是一个圆&amp;quot;,
    func:function(x){
        return x*x*3.14;
    }
};

exports = Circle;  //   看清楚了，Circle这个Object在内存中指向了新的地址，所以exports也指向了这个新的地址，和原来的地址没有半毛钱关系了

console.log(module.exports);    //  { name: &#39;我想改一下名字&#39; }
console.log(exports);   // { name: &#39;我是一个圆&#39;, func: [Function] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回到nodejs中，module.exports初始的时候置为&lt;code&gt;{}&lt;/code&gt;,exports也指向这个空对象。&lt;/p&gt;

&lt;p&gt;那么，这样写是没问题的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports.name = function(x){
    console.log(x);
};

//和下面这个一毛一样，因为都是修改的同一内存地址里的东西


module.exports.name = function(x){
    console.log(x);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这样写就有了区别了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports = function(x){
    console.log(x);
};

//上面的 function是一块新的内存地址，导致exports与module.exports不存在任何关系，而require方能看到的只有module.exports这个对象，看不到exports对象，所以这样写是导不出去的。

//下面的写法是可以导出去的。说句题外话，module.exports除了导出对象，函数，还可以导出所有的类型，比如字符串、数值等。
module.exports = function(x){
    console.log(x);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我讲清楚了吧？&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>