<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on 小明plus</title>
    <link>http://xiaomingplus.com/tags/javascript/</link>
    <description>Recent content in Javascript on 小明plus</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 16 Apr 2016 02:52:18 +0800</lastBuildDate>
    <atom:link href="http://xiaomingplus.com/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>如何使用webpack开始一个react项目?</title>
      <link>http://xiaomingplus.com/front-end/how-to-start-react-redux-react-router-webpack-project/</link>
      <pubDate>Sat, 16 Apr 2016 02:52:18 +0800</pubDate>
      
      <guid>http://xiaomingplus.com/front-end/how-to-start-react-redux-react-router-webpack-project/</guid>
      <description>&lt;p&gt;本文是讲实战操作的，会使用到react,react-router,webpack,babel,react热启动,webpack热启动等，而且本文不准备对原理等进行说明，只想让新手能迅速自己动手生成自己的第一个demo，想了解原理的朋友推荐以下两个教程，讲的非常好。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://survivejs.com/webpack/advanced-techniques/configuring-react/&#34;&gt;http://survivejs.com/webpack/advanced-techniques/configuring-react/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cn.redux.js.org/index.html&#34;&gt;http://cn.redux.js.org/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个是一个讲webpack的配置的教程，是英文版的，有国内的翻译，但是太旧了，所以推荐看英文版本的，第二个是国内翻译的redux教程文档，讲的非常好，暂时还挺新的，如果想看英文版，里面也有对应的链接。&lt;/p&gt;

&lt;p&gt;直接开始吧，本文只讲如何配置，以及如何写一个简单的示例。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意！！！本文在os操作系统下保证可以运行，其他操作系统请勿跟随该示例。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;第一步：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir react-demo
cd react-demo
npm init -y
npm i webpack webpack-dev-server html-webpack-plugin webpack-merge babel-loader babel-core css-loader style-loader babel-preset-react-hmre babel-preset-es2015 babel-preset-react -D
mkdir app
mkdir dist
mkdir assets
touch assets/index.tmpl.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二步，编辑index.tmpl.html为如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;Content-type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;/&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;%= htmlWebpackPlugin.options.title %&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&amp;quot;root&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二步，打开你的&lt;code&gt;package.json&lt;/code&gt;文件,添加如下字符串:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
&amp;quot;scripts&amp;quot;: {    
  &amp;quot;build&amp;quot;: &amp;quot;webpack&amp;quot;,
  &amp;quot;start&amp;quot;: &amp;quot;webpack-dev-server&amp;quot;
},
&amp;quot;babel&amp;quot;:{
  &amp;quot;presets&amp;quot;: [
    &amp;quot;es2015&amp;quot;,
    &amp;quot;react&amp;quot;
  ],
  &amp;quot;env&amp;quot;: {
      &amp;quot;start&amp;quot;: {
        &amp;quot;presets&amp;quot;: [
          &amp;quot;react-hmre&amp;quot;
        ]
      }
    }
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三步：在根目录新建一个&lt;code&gt;webpack.config.js&lt;/code&gt;的文件,写入如下配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const webpack = require(&#39;webpack&#39;);
const merge = require(&#39;webpack-merge&#39;);
const TARGET = process.env.npm_lifecycle_event;
process.env.BABEL_ENV = TARGET;
const PATHS = {
  app: path.join(__dirname, &#39;app&#39;),
  build: path.join(__dirname, &#39;dist&#39;),
  template: path.resolve(__dirname, &#39;assets&#39;, &#39;index.tmpl.html&#39;),
};
const common = {
  entry: {
    app: PATHS.app,
  },
  output: {
    path: PATHS.build,
    filename: &#39;bundle.js&#39;,
  },
  plugins: [
    new HtmlWebpackPlugin({
      title: &#39;react demo&#39;,
      template: PATHS.template,
      inject: &#39;body&#39;,
    }),
  ],
  module: {
    loaders: [{
      test: /\.jsx?$/,
      loaders: [&#39;babel?cacheDirectory&#39;],
      include: PATHS.app,
    }, {
      test: /\.css$/,
      loaders: [&#39;style&#39;, &#39;css&#39;],
      include: PATHS.app,
    }],
  },
  resolve: {
    extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.jsx&#39;],
  },
};
if (TARGET === &#39;start&#39; || !TARGET) {
  module.exports = merge(common, {
    devtool: &#39;eval-source-map&#39;,
    devServer: {
      contentBase: &#39;/dist&#39;,
      historyApiFallback: true,
      hot: true,
      inline: true,
      progress: true,
      stats: &#39;errors-only&#39;,
    },
    plugins: [
      new webpack.HotModuleReplacementPlugin(),
    ],

  });
}
if (TARGET === &#39;build&#39;) {
  module.exports = merge(common, {});
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第四步：到这里，关于react的需要的webpack方面的配置就结束了，接下来我们来写一个很小的示例来生成一个真正的react文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm i react react-dom react-router -S
touch app/App.jsx
touch app/index.jsx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑&lt;code&gt;App.jsx&lt;/code&gt;文件如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import React, { Component } from &#39;react&#39;;
import {
    Router,
    Route,
    Link,
    IndexLink,
    IndexRoute,
    hashHistory,
} from &#39;react-router&#39;;

const activeStyle = {
  color: &#39;#53acff&#39;,
};
const Nav = () =&amp;gt; (
    &amp;lt;div&amp;gt;
        &amp;lt;IndexLink onlyActiveOnIndex activeStyle={activeStyle} to=&amp;quot;/&amp;quot;&amp;gt;主页&amp;lt;/IndexLink&amp;gt;
        &amp;amp;nbsp;
        &amp;lt;IndexLink onlyActiveOnIndex activeStyle={activeStyle} to=&amp;quot;/address&amp;quot;&amp;gt;地址&amp;lt;/IndexLink&amp;gt;
        &amp;amp;nbsp;
    &amp;lt;/div&amp;gt;
);

const Container = (props) =&amp;gt; &amp;lt;div&amp;gt;
    &amp;lt;Nav /&amp;gt; { props.children }
&amp;lt;/div&amp;gt;;

const Twitter = () =&amp;gt; &amp;lt;div&amp;gt;@xiaomingplus twitter&amp;lt;/div&amp;gt;;
const Instagram = () =&amp;gt; &amp;lt;div&amp;gt;@xiaomingplus instagram&amp;lt;/div&amp;gt;;

const NotFound = () =&amp;gt; (
    &amp;lt;h1&amp;gt;404.. 找不到该页面!&amp;lt;/h1&amp;gt;
);
const Home = () =&amp;gt; &amp;lt;h1&amp;gt;你好，这是主页。&amp;lt;/h1&amp;gt;;
const Address = (props) =&amp;gt; &amp;lt;div&amp;gt;
    &amp;lt;br /&amp;gt;
    &amp;lt;Link activeStyle={{ color: &#39;#53acff&#39; }} to=&amp;quot;/address&amp;quot;&amp;gt;这是Twitter&amp;lt;/Link&amp;gt; &amp;amp;nbsp;
    &amp;lt;Link to=&amp;quot;/address/instagram&amp;quot;&amp;gt;这是Instagram&amp;lt;/Link&amp;gt;
    &amp;lt;h1&amp;gt;欢迎互关！&amp;lt;/h1&amp;gt;
    { props.children }
&amp;lt;/div&amp;gt;;


class App extends Component {
  construct() {
  }
  render() {
    return (
        &amp;lt;Router history={hashHistory}&amp;gt;
            &amp;lt;Route path=&amp;quot;/&amp;quot; component={Container}&amp;gt;
                &amp;lt;IndexRoute component={Home} /&amp;gt;
                &amp;lt;Route path=&amp;quot;/address&amp;quot; component={Address}&amp;gt;
                    &amp;lt;IndexRoute component={Twitter} /&amp;gt;
                    &amp;lt;Route path=&amp;quot;instagram&amp;quot; component={Instagram} /&amp;gt;
                &amp;lt;/Route&amp;gt;
                &amp;lt;Route path=&amp;quot;*&amp;quot; component={NotFound} /&amp;gt;
            &amp;lt;/Route&amp;gt;
        &amp;lt;/Router&amp;gt;
    );
  }
}

export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑&lt;code&gt;index.jsx&lt;/code&gt;文件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import App from &#39;./App.jsx&#39;;

ReactDOM.render(
    &amp;lt;App /&amp;gt;, document.getElementById(&#39;root&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ok,到这里你已经实用react-router构建了一个有路由的应用，接下来启动这个应用吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用浏览器访问:&lt;code&gt;http://localhost:8080&lt;/code&gt;,你将看到如下界面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/d9f8fd81gw1f32ivzlj5yj20wi0j240c.jpg&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;http://ww2.sinaimg.cn/large/d9f8fd81gw1f32iyh9nw4j20w60iuwgv.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>几句话理解javascript中的执行上下文、this、作用域、闭包</title>
      <link>http://xiaomingplus.com/front-end/understand-javascript-execution-context-and-this-and-scope-closure/</link>
      <pubDate>Wed, 06 Jan 2016 02:52:18 +0800</pubDate>
      
      <guid>http://xiaomingplus.com/front-end/understand-javascript-execution-context-and-this-and-scope-closure/</guid>
      <description>

&lt;p&gt;这几个问题是javascript问题中的老大难的几个问题，很多文章都有讲过这几个问题，但总也讲不清楚，希望可以尝试用最简单明了的语言把这几个事儿给说清楚了，部分内容并不是官方的定义，而是用简单易懂的语言表达出我所理解的概念。&lt;/p&gt;

&lt;h3 id=&#34;概念:aaa6854c088f9b36a66d3f82ec1dff83&#34;&gt;概念&lt;/h3&gt;

&lt;h4 id=&#34;执行上下文:aaa6854c088f9b36a66d3f82ec1dff83&#34;&gt;执行上下文&lt;/h4&gt;

&lt;p&gt;首先明确一点，所有的js代码都是在某个执行上下文中运行的。&lt;/p&gt;

&lt;p&gt;执行上下文可以看成以下对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;executionContextObj = {
    scopeChain: { /* 作用域链：变量对象+ 所有父执行上下文的变量对象*/ }, 
    variableObject: { /*变量对象：函数 arguments/参数，内部变量和函数声明 */ }, 
    this: { /*运行这个函数的对象(动态的) */ } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js解释器实现了一个执行上下文堆栈，并且总是在栈顶的执行上下文中执行代码。&lt;/p&gt;

&lt;p&gt;当js解释器初始化执行代码时，它首先默认压入一个全局执行上下文到栈中，在此基础上任何一次函数的调用都将压入一个新的执行上下文到栈中，函数执行结束后该执行上下文被弹出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/large/d9f8fd81gw1exnvbj1v68j20ff080my4.jpg&#34; alt=&#34;test&#34; /&gt;&lt;/p&gt;

&lt;p&gt;创建执行上下文是根据按照以下步骤创建的（有先后顺序）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建当前执行上下文的变量对象（在函数中称为活跃对象）：

&lt;ol&gt;
&lt;li&gt;创建arguments对象（如果是函数调用的话），初始化参数名称和值并创建引用的复制。其属性名就是形参的名字，其值就是实参的值；对于没有传递的参数，其值为undefined&lt;/li&gt;
&lt;li&gt;扫描当前执行上下文内的所有函数声明：为发现的每一个函数，在变量对象上创建一个属性，属性名是函数的名字，并且指向函数在内存中的引用，如果变量对象已经包含了相同名字的属性，则替换他的值为当前函数在内存中的引用。（这里的函数扫描只扫描用函数声明定义的函数，不包括函数表达式定义的函数）&lt;/li&gt;
&lt;li&gt;扫描当前执行上下文内的所有变量声明：为发现的每个变量声明，在变量对象上创建一个属性，属性名就是变量的名字，并且将变量的值初始化为undefined，如果变量的名字已经在变量对象里存在，则不会进行任何操作并继续扫描，&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;求出执行上下文内部“this”的值：在全局运行上下文中（在任何函数体外部），this 指代全局对象，无论是否在严格模式下；在函数内部，this的值取决于函数是如何调用的。（关于求this的值，本文后面再讲）&lt;/li&gt;
&lt;li&gt;初始化作用域链：作用域链对执行上下文中的变量对象的有序访问的链表，包括当前执行上下文的变量对象，以及包含了所有上层变量对象的分层链（在函数创建时静态保存在函数中的）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;整个js代码的执行机制就是上面所说的，上面的内容其实包括了执行上下文、作用域链、提升机制，有了以上知识储备，我们再来理解这些难懂的概念就比较容易了：&lt;/p&gt;

&lt;h4 id=&#34;作用域:aaa6854c088f9b36a66d3f82ec1dff83&#34;&gt;作用域&lt;/h4&gt;

&lt;p&gt;作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在js中，变量的作用域有全局作用域和局部作用域两种。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全局作用域：在代码中任何地方都能访问到的对象拥有全局作用域，有以下几种：

&lt;ul&gt;
&lt;li&gt;在最外层定义的变量；&lt;/li&gt;
&lt;li&gt;全局对象的属性；&lt;/li&gt;
&lt;li&gt;任何地方隐式定义的变量（未定义直接赋值的变量），在任何地方隐式定义的变量都会定义在全局作用域中，即不通过 var 声明直接赋值的变量。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;局部作用域：JavaScript的作用域是通过函数来定义的，在一个函数中定义的变量只对这个函数内部可见，称为函数（局部）作用域&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;this:aaa6854c088f9b36a66d3f82ec1dff83&#34;&gt;this&lt;/h4&gt;

&lt;p&gt;在函数执行时，this 总是指向调用该函数的对象。要判断 this 的指向，其实就是判断 this 所在的函数属于谁。
this 出现的场景分为四类，简单的说就是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有对象就指向调用对象&lt;/li&gt;
&lt;li&gt;没调用对象就指向全局对象&lt;/li&gt;
&lt;li&gt;用new构造就指向新对象&lt;/li&gt;
&lt;li&gt;通过 apply 或 call 或 bind 来改变 this 的所指。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;闭包:aaa6854c088f9b36a66d3f82ec1dff83&#34;&gt;闭包&lt;/h4&gt;

&lt;p&gt;闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。闭包是指函数有自由独立的变量。换句话说，定义在闭包中的函数可以“记忆”它创建时候的环境。定义在闭包中的函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。&lt;/p&gt;

&lt;h3 id=&#34;例子:aaa6854c088f9b36a66d3f82ec1dff83&#34;&gt;例子&lt;/h3&gt;

&lt;p&gt;//todo&lt;/p&gt;

&lt;h3 id=&#34;总结:aaa6854c088f9b36a66d3f82ec1dff83&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;//todo&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/&#34;&gt;http://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://segmentfault.com/a/1190000002692982&#34;&gt;http://segmentfault.com/a/1190000002692982&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.5ibc.net/p/17359.html&#34;&gt;http://blog.5ibc.net/p/17359.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yanhaijing.com/javascript/2014/04/30/JavaScript-Scoping-and-Hoisting/&#34;&gt;http://yanhaijing.com/javascript/2014/04/30/JavaScript-Scoping-and-Hoisting/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/alsotang/node-lessons/tree/master/lesson11&#34;&gt;https://github.com/alsotang/node-lessons/tree/master/lesson11&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://segmentfault.com/a/1190000000533094&#34;&gt;http://segmentfault.com/a/1190000000533094&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.k68.org/?p=1831&#34;&gt;http://www.k68.org/?p=1831&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>