<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nodejs on 小明plus</title>
    <link>http://xiaomingplus.com/tags/nodejs/</link>
    <description>Recent content in Nodejs on 小明plus</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 16 Jan 2016 18:21:09 +0800</lastBuildDate>
    <atom:link href="http://xiaomingplus.com/tags/nodejs/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>nodejs中exports和module.exports的区别</title>
      <link>http://xiaomingplus.com/full-stack/understand-nodejs-export-and-module-export/</link>
      <pubDate>Sat, 16 Jan 2016 18:21:09 +0800</pubDate>
      
      <guid>http://xiaomingplus.com/full-stack/understand-nodejs-export-and-module-export/</guid>
      <description>&lt;p&gt;&lt;strong&gt;用一句话来说明就是，require方能看到的只有module.exports这个对象，它是看不到exports对象的，而我们在编写模块时用到的exports对象实际上只是对module.exports的引用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果你能理解上面这句话，那么下面的都是废话，可以不用看了，因为是用来解释上面这句话的。&lt;/p&gt;

&lt;p&gt;关于引用，可以用下面的例子来让你搞得请清楚楚的：&lt;/p&gt;

&lt;p&gt;首先说一个概念：&lt;/p&gt;

&lt;p&gt;ECMAScript的变量值类型共有两种：&lt;/p&gt;

&lt;p&gt;基本类型 (primitive values) ： 包括Undefined, Null, Boolean, Number和String五种基本数据类型；&lt;/p&gt;

&lt;p&gt;引用类型 (reference values) ： 保存在内存中的对象们，不能直接操作，只能通过保存在变量中的地址引用对其进行操作。&lt;/p&gt;

&lt;p&gt;我们今天要讨论的exports和module.exports属于Object类型，属于引用类型。&lt;/p&gt;

&lt;p&gt;看下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var module = {
    exports:{
        name:&amp;quot;我是module的exports属性&amp;quot;
    }
};
var exports = module.exports;  //exports是对module.exports的引用，也就是exports现在指向的内存地址和module.exports指向的内存地址是一样的

console.log(module.exports);    //  { name: &#39;我是module的exports属性&#39; }
console.log(exports);   //  { name: &#39;我是module的exports属性&#39; }


exports.name = &amp;quot;我想改一下名字&amp;quot;;


console.log(module.exports);    //  { name: &#39;我想改一下名字&#39; }
console.log(exports);   //  { name: &#39;我想改一下名字&#39; }
//看到没，引用就是a和b都操作同一内存地址下的数据


//这个时候我在某个文件定义了一个想导出的模块
var Circle = {
    name:&amp;quot;我是一个圆&amp;quot;,
    func:function(x){
        return x*x*3.14;
    }
};

exports = Circle;  //   看清楚了，Circle这个Object在内存中指向了新的地址，所以exports也指向了这个新的地址，和原来的地址没有半毛钱关系了

console.log(module.exports);    //  { name: &#39;我想改一下名字&#39; }
console.log(exports);   // { name: &#39;我是一个圆&#39;, func: [Function] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回到nodejs中，module.exports初始的时候置为&lt;code&gt;{}&lt;/code&gt;,exports也指向这个空对象。&lt;/p&gt;

&lt;p&gt;那么，这样写是没问题的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports.name = function(x){
    console.log(x);
};

//和下面这个一毛一样，因为都是修改的同一内存地址里的东西


module.exports.name = function(x){
    console.log(x);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这样写就有了区别了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports = function(x){
    console.log(x);
};

//上面的 function是一块新的内存地址，导致exports与module.exports不存在任何关系，而require方能看到的只有module.exports这个对象，看不到exports对象，所以这样写是导不出去的。

//下面的写法是可以导出去的。说句题外话，module.exports除了导出对象，函数，还可以导出所有的类型，比如字符串、数值等。
module.exports = function(x){
    console.log(x);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我讲清楚了吧？&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>