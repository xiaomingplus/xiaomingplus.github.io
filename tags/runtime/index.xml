<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Runtime on 小明plus</title>
    <link>http://xiaomingplus.com/tags/runtime/</link>
    <description>Recent content in Runtime on 小明plus</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 05 Oct 2016 18:21:09 +0800</lastBuildDate>
    <atom:link href="http://xiaomingplus.com/tags/runtime/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>javascript到底是如何运行的？</title>
      <link>http://xiaomingplus.com/full-stack/how-to-run-for-javascript/</link>
      <pubDate>Wed, 05 Oct 2016 18:21:09 +0800</pubDate>
      
      <guid>http://xiaomingplus.com/full-stack/how-to-run-for-javascript/</guid>
      <description>

&lt;p&gt;每次看到别人在讲javascript单线程、事件循环、运行时、执行栈都似懂非懂，今天看了很多相关资料说一说我的理解吧。&lt;/p&gt;

&lt;p&gt;javascript的运行机制可抽象为3部分，一部分是[执行栈]，一部分为[任务队列]，另外一部分为[观察者]。&lt;/p&gt;

&lt;h3 id=&#34;执行栈:d81a74552a4354e292895fa1ef7087b1&#34;&gt;执行栈&lt;/h3&gt;

&lt;p&gt;[执行栈]就是我们常说的js的单线程，也叫主线程，js代码在这里被一行一行的执行，[执行栈]遇到它能搞定的语句，包括所有的计算型的语句，以及普通的函数回调，都能在这里直接执行。当[执行栈]遇到自己处理不了的语句(比如setTimeout，ajax，文件读取等)，那么它会把这个语句交给[观察者].&lt;/p&gt;

&lt;h3 id=&#34;观察者:d81a74552a4354e292895fa1ef7087b1&#34;&gt;观察者&lt;/h3&gt;

&lt;p&gt;在js中，有多种类型的观察者，包括文件I/O观察者,网络请求观察者等（其实这里的观察者一般来讲就是宿主环境提供的API），[执行栈]会把自己搞不定的事情丢给相应类型的[观察者],[观察者]负责在该事情处理之后会把带着处理结果的回调函数加入[任务队列]。&lt;/p&gt;

&lt;h3 id=&#34;任务队列:d81a74552a4354e292895fa1ef7087b1&#34;&gt;任务队列&lt;/h3&gt;

&lt;p&gt;一个JavaScript运行时包含一个待处理的任务队列，该队列是先进先出的，队列里的每一个任务都与一个函数相关联（一般是调用API时指定的回调函数）。当[执行栈]为空时，[执行栈]会从[任务队列]中取出队列里最前面的一个任务进行处理。处理过程包含了调用与这个任务相关联的函数（以及因此而创建的一个初始栈结构）。当[执行栈]再次为空的时候，意味着该任务处理结束， [执行栈]会循环去[任务队列]取出排在最前面的任务，然后执行之，也就是说每一个任务在执行完成后（执行当前任务的执行栈为空的时候），其它任务才会被执行。如果任务队列里没有任务了，那执行栈会同步的等待任务队列的任务到来。&lt;/p&gt;

&lt;p&gt;用一张图来表示的话，如下图所示:
&lt;img src=&#34;http://ww4.sinaimg.cn/large/d9f8fd81gw1f8ho2qks9nj20m70jy3zf.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;举例来讲：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
//0. 首先初始化本次执行栈,压入一个初始化的东西
console.log(&#39;a1&#39;);//1. 把console.log和压入执行栈,执行后就弹出（console.log这种事情执行栈完全可以处理）

var average = function(x,y,callback){
    callback((x+y)/2);
}

var start = function(){

    setTimeout(function(){

        console.log(&#39;time!&#39;);//13. 把console.log压入执行栈，执行后弹出
        //14. 到这里后，setTimeout的回调函数已执行完毕，弹出该函数

    },1000);//3. 把setTimeout压入执行栈,发现执行栈无法处理setTimeout函数，于是把setTimeout交给时间观察者，执行栈弹出setTimeout,时间观察者会在时间到了之后把回调函数加入任务队列。
    
    average(3,5,function(result){

        console.log(result);//4.1 这里的回调函数不会加入任务队列，因为这种普通的回调执行栈自己完全可以处理，不需要观察者帮忙。这里会打印出4
    
    })//4. 把average压入执行栈，执行完average函数后弹出average函数

    //5. 到这里后，start函数已执行完毕，弹出start函数
}

var end = function(){

    console.log(&#39;end!&#39;);//7. 把console.log压入执行栈，执行后弹出
    
    //8. 到这里后，end函数已执行完毕，弹出end函数
}

start();//2. 把start压入执行栈

end();//6. 到这里后,执行栈只剩下初始化的那个东西，把end压入执行栈

//9. 到这里后已经没有代码可执行，弹出初始化的那个东西，执行栈为空了
//10. 执行栈为空之后，它便去任务队列读取排在最前面的那个任务，发现任务队列里没有任务，于是同步的等待任务队列，1s过后，任务队列里会出现刚刚setTimeout时指定的回调函数。
//11. 初始化本次执行栈，压入一个初始化的东西
//12. 把setTimeout的回调函数压入执行栈
//15. 到这里后已经没有代码可执行，弹出第二次初始化的那个东西，执行栈为空了
//16. 执行栈为空之后，它便去任务队列读取排在最前面的那个任务，发现任务队列里没有任务，于是同步的等待任务队列。（看这情况，也不会出现别的任务了。。。）

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>